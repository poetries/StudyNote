类和对象：
	类：主观抽象，是对象的模板，可以实例化对象
		习惯上类的定义格式：
			package xxx;		
			import xxx;		
			public class Xxxx{
				属性 ・・・・・・;
				
				构造器 ・・・・・・;
				
				方法 ・・・・・・;
			}

		定义属性：实例变量
			格式：[ 修饰符 ]  类型 变量名  [ = ? ]
			实例变量定义在类中但在任何方法之外。
			实例变量有默认值：各种各样的0。(同数组)
			实例变量的作用域至少在本类内部，受访问控制符的限制。
			在重合作用域，实例变量和局部变量允许有命名冲突，“局部优先”。
			
		定义方法：
			格式： [ 修饰符 ]  返回类型 方法名( 参数列表 ) [ throws  异常 ] { ・・・・・・ } 
			java中所有参数都是值传递。
	   		当没有值返回时，返回类型必须被定义为void。 
			返回类型必须与方法名相邻，其他修饰符可以调换位置。
			
		构造器：
			在创建对象的过程中调用的方法。
			构造器没有返回类型。
			构造器的名字与类名相同。
			格式为：[ 修饰符 ]  类名( 参数列表 ){  }，修饰符可以是private、 protected、 default、private
			在一个对象的生成周期中构造器只用一次，由系统自动调用，不允许手工调用。
			程序员没有提供一个构造器，系统会自动提供一个无参的构造器。
			获得对象的方式：
				通过new（在堆空间中申请分配空间），new 类名()，可以通过这种形式或的一个对象，这时的对象是无法使用，必须把他的地址存放进一个对象变量才能够使用。
				例如 ：
					Car c=new Car();
			注意：
				最好在写类时提供一个无参的构造器。
						
		this关键字：
			this是个隐式参数，代表当前对象;
				publie class Student{
					private String name;
					public void setName(String name){
						this.name=name;		//this.name为当前对象的成员变量
					}
				}
				
			如果某个构造方法的第一个语句具有形式this( ・・・ )，那么这个构造方法将调用同一类中的其他构造方法。
			
        		注意：
        			在构造器中this(...)必须放在该构造器的第一行。
				this不能出现在静态方法里面		
	
	类、对象、实例三者的关系：
		类：是对象的模板，可以实例化对象
		对象：类的个体
		实例：实现的对象
		student s;	
		s=new student();
			其中 Student为类，s为对象，new Student()为实例，s赋值后也是实例了。

方法重载：
	方法名相同，参数表不同，不考虑返回值类型(但最好还是使返回类型一致)。
	编译器根据参数，选择一个方法，如果没有完全匹配的，对于参数表采用“向上就近匹配原则”，但不允许模棱两可。
	方法重载屏蔽了一个对象的同一类方法由于参数不同所造成的差异。
			
封装：
	类的属性加private修饰符，来限制只能够在类的内部进行访问，有效的保护数据。
	对于类中的私有属性，要对其给出一对方法getXxx()，setXxx()访问私有属性，保证对私有属性的操作的安全性。
	方法公开的是方法的声明，即只须知道参数和返回值就可以调用该方法，隐藏方法的实现的细节。
	一个对象和外界的联系应当通过一个统一的接口，应当公开的公开，应当隐藏的隐藏。
		
继承：
	父类到子类是从一般到特殊的关系。
		泛化：将不同子类中的共性抽象成父类的过程。
		特化：在原有父类的基础上加入一些个性的过程。
		原则：父类放共性，子类放个性。
	继承的关键字：extends
	Java只支持单继承：一个类最多只有一个直接的父类。

     	方法覆盖：
		方法名：相同
		参数表：相同
		访问限制符：相同或者更宽
		返回值类型：相同或者子类返回的类型是父类返回的类型的子类（在JDK5.0以后）
		抛出的异常：不能比父类更宽。
     
     	super关键字：
		super()表示调用父类的构造器
		super()也和this()一样必须放在方法的第一句
		super()和this()不能同时出现         
		super可以屏蔽子类属性和父类属性重名时带来的属性遮盖，super. 表示调用父类的方法或属性
		在子类的构造器中如果没有指定调用父类的哪一个构造器，那么就会调用父类的无参构造器，即super()
		
	注意：
		父类的构造器不能被子类继承
		方法和属性可以被继承，权限不限制能否继承过来，限制的是能否直接访问
		先构造父类，后构造子类，先this后super
		
多态：
	多态分为两种：编译时多态和运行时多态。
		编译时类型：主观概念，把它看作什么。
		运行时类型：客观概念，实际它是什么。
	  	例：Animal a=new Dog();
	      		指着狗问，这个动物是什么？
	      		
     	运行时多态的三原则：
		对象类型不变。
		只能对对象调用编译时类型中定义的方法。
		在程序的运行时，根据对象的运行时类型，找覆盖后的方法来调用。（运行时动态类型绑定）
		
     	强制类型转换： 一定没有新对象生成。(父类的引用赋值给子类的引用需要进行强制类型转换)
     	关键字：instanceof
          	用法：引用  instanceof  类名    判断这个引用所指向的对象是否属于这个类。
	  	用在强制转换之前，避免类型转换异常。
			if(a instanceof Dog){
				Dog d=(Dog)a;
			}
			
	多态的作用：把不同的子类对象都当作父类来看，可以屏蔽不同子类对象之间的差异，写出通用的代码，做出通用的编程，以适应需求的不断变化。