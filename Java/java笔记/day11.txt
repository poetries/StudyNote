多线程：
	进程与线程：
		进程：同一个操作系统中执行的一个子程序，包含了三部分虚拟CPU、代码、数据
		多进程：同一个操作系统中执行的多个并行的子程序。可以提高cpu的使用率
		线程：在同一个进程当中执行的子程序流
		多线程：同一个进程当中并发执行的多个子程序流。可以提高cpu的使用率
		进程与线程的区别：
			进程有独立的进程空间，进程中的数据存放空间（堆空间和栈空间）是独立的。
			线程的堆空间是共享的，栈空间是独立的，线程消耗的资源也比进程小，相互之间可以影响的。
		java中如何调进程：
			调用本地程序的两个类
				Runtime
					Runtime.getRuntime.exec(...);	//执行一个程序
						其返回值就是Process类型
				Process		
		注意：
			只有运行状态的线程才有机会执行代码，主线程的中止不会影响其他的正在运行中的线程，主线程中止也就是main()方法退出了。只有进程中的所有线程都中止时，进程（JVM进程）才会退出，只要有线程没有中止，进程就不会退出。
			操作系统决定线程是否有优先级，独占式的操作系统中系统会有优先级的概念，共享式的操作系统则不会有优先级的。
			在线程的内部，程序依然顺序执行
	
	线程编程的两种方法：
		写一个类，继承Thread类，覆盖Thread类中继承来的run()方法，这样就写好了自定义的线程类。
			继承java.lang.Thread类：
				class MyThread extends Thread{
	   				public void run(){		//覆盖run()，线程体方法，自身其实就是普通的方法
	   					.......
					}
				}
	 		启动线程：
				public class TestThread{
	  				public static void main(){
	  					Thread t1=new Mythread();
	  					T1.start();		//调用start()来启动线程，线程启动方法，向线程调度器说明当前线程已经准备好了，是一种可运行状态
	  				}
				}
				
		写一个类，实现Runable接口，实现其中的run()方法。这种方法写好的类的对象需要作为线程类创建对象时构造方法的参数。
			实现java.lang.Runnable接口：
				Class MyThread  implements Runnable{
		  			public void run(){
				
		  			}
				}
	 		启动线程：
				public class TestThread{
					public static void main(){
						Runnable myThread = new MyThread();
						Thread t = new Thread(myThread);
						t.start();
					}
				}
				
	Thread中的一些方法：
		currentThread() 
	          	返回对当前正在执行的线程对象的引用(实现接口方式时使用)
		sleep(long millis) 
          		在指定的毫秒数内让当前正在执行的线程休眠(暂停执行)。
			本线程不会去抢，除非sleep结束。
			多个线程之间都会去抢执行权限，不会考虑优先级。
		yield() 
          		暂停当前正在执行的线程对象，并执行其他线程。
          		只给本类或者优先级大于本类优先级的线程去抢。
          	join() 
          		等待该线程终止。	
          		放在start()前面则没有用处。
          	setDaemon(boolean on) 
          		将该线程标记为守护线程，守护线程需要依赖其他线程，会在虚拟机停止的时候停止。
		          		
	线程的生命周期：
		1）初始状态：此时线程只是处于JVM进程中，只是创建了一个线程对象，并没有真正开始运行。
		2）可动行状态：调用线程对象的start()方法，此时线程才真正的被创建，进入可运行状态，等待CPU的调度。“万事俱备，只欠CPU”。
		3）运行状态：正在运行的线程，此时它拥有CPU的执行权。
		4）阻塞状态：运行状态中的线程，如果正在等待用户输入或调用了sleep()和join()等方法都会导致线程进入阻塞状态，注意从阻塞状态出来的线程不一定马上回到运行状态，而是重新回到可运行状态，等待CPU的再次调度。
		5）等待队列状态：一个线程调用一个对象的wait()会自动放弃该对象的锁标记，进入等待队列状态，只有当有另外一线程调用临界资源的notify()或notifyAll()方法，建议多使用notifyAll()，才会将等待队列中的线程释放，此线程进入锁池状态。
		6）锁池状态：每个对象都有互斥锁标记，以防止对临界资源的访问造成数据的不一致，和数据的不完整性。一个线程拥有一个对象的锁标记后，另一线程想访问该对象，必须在锁池中等待。由系统决定哪个线程拿到锁标记并运行。注意从锁池状态出来的线程不是马上回到运行状态，而是重新回到可运行状态，等待CPU的再次调度。
		7）终止状态：一个线程运行结束后称为终止状态，一个进程中只有所有的线程退出后才会终止。