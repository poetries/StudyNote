/*
	super的使用
*/

class A
{
	A()
	{
		System.out.println("AAAA");
	}

	A(int i)
	{
	}
}

class B extends A
{
	B()
	{
		super(2); //如果把该语句注释掉的化，则编译器默认的是自动隐藏调用super(); 但如果父类没有无参的构造函数，则会报错
				  //一个子类的构造函数中只能出现一个 super(....)
		System.out.println("BBBB");
	}
}

class C extends B
{
	C() 
	{
		//int k = 10; //如果该语句生效 则会出错，因为会导致super()语句不是构造函数的第一条语句
		
		super();  //35行  每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有无参的构造函数，那么在编译的时候就会报错。
				  //super();语句可以写，也可以不写，不写的化，系统会自动调用的
				  //如果显示写出来的话，编译器要求该语句前面不能加任何语句，也就是说该语句必须保证是第一条语句
				  // super()也可以改为super(2); 但前提是父类必须有带一个参数的构造函数，否则也会报错				
				  //如果把35行改为 super(2); 编译时就会报错!  

		System.out.println("CCCC");
	}
}

class  TestSuper_1
{
	public static void main(String[] args) 
	{
		C cc = new C();

		//System.out.println("Hello World!");
	}
}
/*
	在j2sdk1.4.2_16中的运行结果是：
-----------------------
BBBB
CCCC
-----------------------
	 总结：
		1、每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的
		   构造函数，那么在编译的时候就会报错。
		2、如果显示的写出super();语句，则必须保证该语句是第一条语句，否则会出错
		3、super();如果不写，则编译器会自动添加,所以此时如果父类没有无参的构造函数就会出错
		4、既可以显示写super();前提是父类必须有无参的构造函数
		   也可以显示写super(实参); 前提是父类必须有带参的构造函数
		5、调用父类的构造函数的语句必须借助于super,不能直接写父类的类名，这与C++不同，
		6、一个构造函数中不能写多个super(参数列表)语句
*/
